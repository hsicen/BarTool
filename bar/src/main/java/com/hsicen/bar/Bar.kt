package com.hsicen.barimport android.annotation.SuppressLintimport android.app.Activityimport android.content.Contextimport android.content.res.Configurationimport android.content.res.Resourcesimport android.graphics.Colorimport android.os.Buildimport android.util.DisplayMetricsimport android.util.TypedValueimport android.view.Viewimport android.view.Windowimport android.view.WindowManagerimport androidx.annotation.ColorIntimport androidx.annotation.FloatRangeimport com.hsicen.bar.Constants.IMMERSE_NAVIGATION_BAR_HEIGHTimport com.hsicen.bar.Constants.IMMERSE_NAVIGATION_BAR_HEIGHT_LANDSCAPEimport com.hsicen.bar.Constants.IMMERSE_NAVIGATION_BAR_WIDTHimport com.hsicen.bar.Constants.IMMERSE_STATUS_BAR_HEIGHT/** * Bar 信息相关 */interface OnBarListener {  fun onBarChange(property: BarProperty)}sealed class BarState {  /*** 显示状态栏和导航栏 */  data object FLAG_SHOW_BAR : BarState()  /*** 隐藏状态栏和导航栏 */  data object FLAG_HIDE_BAR : BarState()  /*** 隐藏状态栏 */  data object FLAG_HIDE_STATUS_BAR : BarState()  /*** 隐藏导航栏 */  data object FLAG_HIDE_NAVIGATION_BAR : BarState()}data class BarProperty(  /*** 是否是竖屏 */  var portrait: Boolean = false,  /*** 是否是左横屏 */  var landscapeLeft: Boolean = false,  /*** 是否是右横屏 */  var landscapeRight: Boolean = false,  /*** 是否是刘海屏 */  var notchScreen: Boolean = false,  /*** 是否有底部导航栏 */  var hasNavigationBar: Boolean = false,  /*** 状态栏高度 */  var statusBarHeight: Int = 0,  /*** 导航栏高度 */  var navigationBarHeight: Int = 0,  /*** 导航栏宽度 */  var navigationBarWidth: Int = 0,  /*** 刘海屏高度 */  var notchHeight: Int = 0,  /*** ActionBar高度 */  var actionBarHeight: Int = 0)class BarParams : Cloneable {  /*** 状态栏颜色 */  @ColorInt  var statusBarColor = Color.TRANSPARENT  /*** 导航栏颜色 */  @ColorInt  var navigationBarColor = Color.BLACK  /*** 默认导航栏颜色 */  var defaultNavigationBarColor = Color.BLACK  /*** 状态栏透明度 */  @FloatRange(from = 0.0, to = 1.0)  var statusBarAlpha = 0.0f  /*** 状态栏临时透明度 */  @FloatRange(from = 0.0, to = 1.0)  var statusBarTempAlpha = 0.0f  /*** 导航栏透明度 */  @FloatRange(from = 0.0, to = 1.0)  var navigationBarAlpha = 0.0f  /*** 导航栏临时透明度 */  @FloatRange(from = 0.0, to = 1.0)  var navigationBarTempAlpha = 0.0f  /*** 有导航栏的情况，全屏显示 */  var fullScreen = false  /*** 是否隐藏了导航栏 */  var hideNavigationBar = false  /*** 状态栏和导航栏状态 */  var barState: BarState = BarState.FLAG_SHOW_BAR  /*** 状态栏字体深色与亮色标志位 */  var statusBarDarkFont = false  /*** 导航栏图标深色与亮色标志位 */  var navigationBarDarkIcon = false  /*** 是否启用 自动根据StatusBar颜色调整深色模式与亮色模式 */  var autoStatusBarDarkModeEnable = false  /*** 是否启用 自动根据NavigationBar颜色调整深色模式与亮色模式 */  var autoNavigationBarDarkModeEnable = false  /*** 状态栏深色模式自动调节时，状态栏字体颜色 */  @FloatRange(from = 0.0, to = 1.0)  var autoStatusBarDarkModeAlpha = 0.0f  /*** 导航栏深色模式自动调节时，导航栏图标颜色 */  @FloatRange(from = 0.0, to = 1.0)  var autoNavigationBarDarkModeAlpha = 0.0f  /*** 是否可以修改状态栏颜色 */  var statusBarColorEnabled = true  /*** 状态栏变换后的颜色 */  @ColorInt  var statusBarColorTransform = Color.BLACK  /*** 导航栏变换后的颜色 */  @ColorInt  var navigationBarColorTransform = Color.BLACK  /*** 支持view变色 */  var viewMap: HashMap<View?, Map<Int, Int>> = HashMap()  /*** view的透明度 */  @FloatRange(from = 0.0, to = 1.0)  var viewAlpha = 0.0f  /*** 内容背景色 */  @ColorInt  var contentColor = Color.TRANSPARENT  /*** 内容背景色变换后的颜色 */  @ColorInt  var contentColorTransform = Color.BLACK  /*** 内容背景色透明度 */  @FloatRange(from = 0.0, to = 1.0)  var contentAlpha = 0.0f  /*** 解决标题栏与状态栏重叠问题 */  var fits = false  /*** 解决标题栏与状态栏重叠问题 */  var titleBarView: View? = null  /*** 解决标题栏与状态栏重叠问题 */  var statusBarView: View? = null  /*** 是否可以解决标题栏与状态栏重叠问题 */  var fitsLayoutOverlapEnable = true  /*** flymeOS状态栏字体变色 */  @ColorInt  var flymeOSStatusBarFontColor = 0  @ColorInt  var flymeOSStatusBarFontTempColor = 0  /*** 结合actionBar使用 */  var isSupportActionBar = false  /*** 解决软键盘与输入框冲突问题 */  var keyboardEnable = false  /*** 软键盘属性 */  var keyboardMode: Int = (WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN    or WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)  /*** 是否能修改导航栏颜色 */  var navigationBarEnable = true  /*** 否能修改4.4手机以及华为emui3.1导航栏颜色 */  var navigationBarWithKitkatEnable = true  /*** 是否可以修改emui3系列手机导航栏 */  var navigationBarWithEMUI3Enable = true  /*** 是否可以沉浸式 */  var barEnable = true  /*** 横竖屏监听 */  var onBarListener: OnBarListener? = null  /*** 软键盘监听 */  var onKeyboardListener: OnKeyboardListener? = null  /*** 导航栏显示隐藏监听 */  var onNavigationBarListener: OnNavigationBarListener? = null  public override fun clone(): BarParams {    return kotlin.runCatching {      super.clone() as BarParams    }.getOrNull() ?: BarParams()  }}class BarConfig(act: Activity) {  companion object {    fun getInternalDimensionSize(act: Context, key: String): Int {      return kotlin.runCatching {        val resId = Resources.getSystem()          .getIdentifier(key, "dimen", "android")        if (resId > 0) {          val sizeOne = act.resources.getDimensionPixelSize(resId)          val sizeTwo = Resources.getSystem().getDimensionPixelSize(resId)          if (sizeTwo >= sizeOne            && (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && key != IMMERSE_STATUS_BAR_HEIGHT).not()          ) {            sizeTwo          } else {            val densityOne = act.resources.displayMetrics.density            val densityTwo = Resources.getSystem().displayMetrics.density            val smallerSize = (sizeOne * densityTwo) / densityOne            if (smallerSize >= 0)              (smallerSize + 0.5f).toInt()            else              (smallerSize - 0.5f).toInt()          }        } else 0      }.getOrNull() ?: 0    }    fun getNavigationBarHeightInternal(act: Context): Int {      val key = if (act.resources.configuration.orientation        == Configuration.ORIENTATION_PORTRAIT      ) {        IMMERSE_NAVIGATION_BAR_HEIGHT      } else {        IMMERSE_NAVIGATION_BAR_HEIGHT_LANDSCAPE      }      return getInternalDimensionSize(act, key)    }    fun getNavigationBarWidthInternal(act: Context): Int {      return getInternalDimensionSize(act, IMMERSE_NAVIGATION_BAR_WIDTH)    }  }  val mSmallestWidthDp by lazy { getSmallestWidthDp(act) }  val mActionBarHeight by lazy { getActionBarHeight(act) }  val mHasNavigationBar by lazy { mNavigationBarHeight > 0 }  val mNavigationBarWidth by lazy { getNavigationBarWidth(act) }  val mNavigationBarHeight by lazy { getNavigationBarHeight(act) }  val mStatusBarHeight by lazy { getInternalDimensionSize(act, IMMERSE_STATUS_BAR_HEIGHT) }  val mInPortrait by lazy { act.resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT }  fun isNavigationAtBottom() = (mSmallestWidthDp >= 600 || mInPortrait)  private fun getNavigationBarWidth(act: Activity): Int {    if (hasNavBar(act)) {      return getNavigationBarWidthInternal(act)    }    return 0  }  private fun getNavigationBarHeight(act: Activity): Int {    if (hasNavBar(act)) {      return getNavigationBarHeightInternal(act)    }    return 0  }  private fun getActionBarHeight(act: Activity): Int {    return kotlin.runCatching {      var result = 0      val actionBar = act.window.findViewById<View>(R.id.action_bar_container)      if (actionBar != null) {        result = actionBar.measuredHeight      }      if (0 == result) {        val typedValue = TypedValue()        act.theme.resolveAttribute(android.R.attr.actionBarSize, typedValue, true)        result = TypedValue.complexToDimensionPixelSize(          typedValue.data, act.resources.displayMetrics        )      }      result    }.getOrNull() ?: 0  }  private fun getSmallestWidthDp(act: Activity): Float {    val dm = DisplayMetrics()    act.windowManager.defaultDisplay.getRealMetrics(dm)    val widthInDp = dm.widthPixels / dm.density    val heightInDp = dm.heightPixels / dm.density    return widthInDp.coerceAtMost(heightInDp)  }  private fun hasNavBar(act: Activity): Boolean {    val bean = GestureUtils.getGestureBean(act)    if (bean.checkNavigation.not() && bean.isGesture) {      return false    }    val d = act.windowManager.defaultDisplay    val realD = DisplayMetrics()    d.getRealMetrics(realD)    val rW = realD.widthPixels    val rH = realD.heightPixels    val dm = DisplayMetrics()    d.getMetrics(dm)    val dW = dm.widthPixels    val dH = dm.heightPixels    return (rW - dW > 0 || rH - dH > 0)  }}object BarFontUtils {  private const val SYSTEM_UI_FLAG_LIGHT_STATUS_BAR = 0  private val mSetStatusBarColorIcon by lazy {    kotlin.runCatching {      Activity::class.java.getMethod("setStatusBarDarkIcon", Int::class.java)    }.getOrNull()  }  private val mSetStatusBarDarkIcon by lazy {    kotlin.runCatching {      Activity::class.java.getMethod("setStatusBarDarkIcon", Boolean::class.java)    }.getOrNull()  }  private val mStatusBarColorFiled by lazy {    kotlin.runCatching {      WindowManager::class.java.getDeclaredField("statusBarColor")    }.getOrNull()  }  /*** 颜色转换成灰度值 */  fun toGrey(rgb: Int): Int {    val blue = rgb and 0x000000FF    val green = (rgb and 0x0000FF00) shr 8    val red = (rgb and 0x00FF0000) shr 16    return (red * 38 + green * 75 + blue * 15) shr 7  }  /*** 判断颜色是否偏黑色 */  fun isBlackColor(color: Int, level: Int = 50): Boolean {    val grey = toGrey(color)    return grey < level  }  /*** 设置状态栏字体图标颜色 */  fun setStatusBarDarkIcon(act: Activity?, color: Int) {    act ?: return    if (mSetStatusBarColorIcon != null) {      kotlin.runCatching {        mSetStatusBarColorIcon?.invoke(act, color)      }    } else {      val whiteColor = isBlackColor(color, 50)      mStatusBarColorFiled?.let {        setStatusBarDarkIcon(act, whiteColor, whiteColor)        setStatusBarDarkIcon(act.window, color)      } ?: setStatusBarDarkIcon(act, whiteColor)    }  }  /*** 设置状态栏字体图标颜色(只限全屏非activity情况) */  fun setStatusBarDarkIcon(window: Window?, color: Int) {    window ?: return    setStatusBarColor(window, color)    setStatusBarDarkIcon(window.decorView, true)  }  /*** 设置状态栏字体图标颜色 */  fun setStatusBarDarkIcon(act: Activity?, dark: Boolean) {    act ?: return    setStatusBarDarkIcon(act, dark, true)  }  /*** 设置状态栏字体图标颜色(只限全屏非activity情况) */  fun setStatusBarDarkIcon(window: Window?, dark: Boolean) {    window ?: return    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {      changeMeizuFlag(window.attributes, "MEIZU_FLAG_DARK_STATUS_BAR_ICON", dark)    } else {      setStatusBarDarkIcon(window.decorView, dark)      setStatusBarColor(window, 0)    }  }  /*** MIUI 系统状态栏颜色设置 */  @SuppressLint("PrivateApi")  fun setMIUIBarDark(window: Window?, key: String, dark: Boolean) {    val clazz = window?.javaClass ?: return    kotlin.runCatching {      val lp = Class.forName("android.view.MiuiWindowManager\$LayoutParams")      val field = lp.getField(key)      val darkModeFlag = field.getInt(lp)      val extraFlagField = clazz.getMethod("setExtraFlags", Int::class.java, Int::class.java)      if (dark) {        //状态栏透明且黑色字体        extraFlagField.invoke(window, darkModeFlag, darkModeFlag)      } else {        //清除黑色字体        extraFlagField.invoke(window, 0, darkModeFlag)      }    }  }  /*** 设置状态栏字体图标颜色 */  private fun setStatusBarDarkIcon(act: Activity?, dark: Boolean, flag: Boolean) {    act ?: return    if (mSetStatusBarDarkIcon != null) {      kotlin.runCatching {        mSetStatusBarDarkIcon?.invoke(act, dark)      }    } else {      if (flag) setStatusBarDarkIcon(act.window, dark)    }  }  /*** 设置状态栏颜色 */  private fun setStatusBarDarkIcon(view: View?, dark: Boolean) {    kotlin.runCatching {      val oldVis = view?.systemUiVisibility ?: return      var newVis = oldVis      newVis = if (dark) {        newVis or SYSTEM_UI_FLAG_LIGHT_STATUS_BAR      } else {        newVis and SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv()      }      if (newVis != oldVis) {        view.systemUiVisibility = newVis      }    }  }  /*** 设置状态栏颜色 */  private fun setStatusBarColor(window: Window?, color: Int) {    val winParams = window?.attributes ?: return    val filed = mStatusBarColorFiled ?: return    kotlin.runCatching {      val oldColor = filed.getInt(winParams)      if (oldColor != color) {        filed.set(winParams, color)        window.attributes = winParams      }    }  }  /*** 魅族手机状态栏颜色设置 */  private fun changeMeizuFlag(lp: WindowManager.LayoutParams?, name: String, on: Boolean) {    kotlin.runCatching {      val field = lp?.javaClass?.getDeclaredField(name) ?: return      field.isAccessible = true      val bits = field.getInt(lp)      val field2 = lp.javaClass.getDeclaredField("meizuFlags")      field2.isAccessible = true      var flags = field2.getInt(lp)      val oldFlags = flags      flags = if (on) {        flags or bits      } else flags and bits.inv()      if (oldFlags != flags) {        field2.setInt(lp, flags)      }    }  }}