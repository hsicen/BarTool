@file:Suppress("DEPRECATION")package com.hsicen.barimport android.app.Activityimport android.app.Dialogimport android.content.Contextimport android.content.res.Configurationimport android.graphics.Colorimport android.os.Buildimport android.view.*import android.view.ViewGroup.LayoutParams.MATCH_PARENTimport android.view.ViewGroup.LayoutParams.WRAP_CONTENTimport android.widget.FrameLayoutimport androidx.annotation.*import androidx.core.content.ContextCompatimport androidx.core.graphics.ColorUtilsimport androidx.drawerlayout.widget.DrawerLayoutimport androidx.fragment.app.DialogFragmentimport androidx.fragment.app.Fragmentimport com.hsicen.bar.Constants.FLAG_FITS_DEFAULTimport com.hsicen.bar.Constants.FLAG_FITS_STATUSimport com.hsicen.bar.Constants.FLAG_FITS_SYSTEM_WINDOWSimport com.hsicen.bar.Constants.FLAG_FITS_TITLEimport com.hsicen.bar.Constants.FLAG_FITS_TITLE_MARGIN_TOPimport com.hsicen.bar.Constants.IMMERSE_BOUNDARY_COLORimport com.hsicen.bar.Constants.IMMERSE_NAVIGATION_BAR_DARK_MIUIimport com.hsicen.bar.Constants.IMMERSE_NAVIGATION_BAR_VIEW_IDimport com.hsicen.bar.Constants.IMMERSE_STATUS_BAR_DARK_MIUIimport com.hsicen.bar.Constants.IMMERSE_STATUS_BAR_VIEW_IDimport kotlin.math.abs/** * 沉浸式状态栏处理相关 */interface ImmerseCallback : OnNavigationBarListener, Runnableclass ImmerseBar : ImmerseCallback {  companion object {    /*** 在Activity使用 */    @JvmStatic    fun with(act: Activity?) =      getRetriever().get(act, false)    /*** 在Activity使用 */    @JvmStatic    fun with(act: Activity?, isOnly: Boolean) =      getRetriever().get(act, isOnly)    /*** 在Fragment使用 */    @JvmStatic    fun with(fragment: Fragment?) =      getRetriever().get(fragment, false)    /*** 在Fragment使用 */    @JvmStatic    fun with(fragment: Fragment?, isOnly: Boolean) =      getRetriever().get(fragment, isOnly)    /*** 在Fragment使用 */    @JvmStatic    fun with(fragment: android.app.Fragment?) =      getRetriever().get(fragment, false)    /*** 在Fragment使用 */    @JvmStatic    fun with(fragment: android.app.Fragment?, isOnly: Boolean) =      getRetriever().get(fragment, isOnly)    /*** 在DialogFragment使用 */    @JvmStatic    fun with(fragment: DialogFragment?) =      getRetriever().get(fragment, false)    /*** 在DialogFragment使用 */    @JvmStatic    fun with(fragment: DialogFragment?, isOnly: Boolean) =      getRetriever().get(fragment, isOnly)    /*** 在DialogFragment使用 */    @JvmStatic    fun with(fragment: android.app.DialogFragment?) =      getRetriever().get(fragment, false)    /*** 在DialogFragment使用 */    @JvmStatic    fun with(fragment: android.app.DialogFragment?, isOnly: Boolean) =      getRetriever().get(fragment, isOnly)    /*** 在dialog里使用 */    @JvmStatic    fun with(act: Activity?, dialog: Dialog?) =      getRetriever().get(act, dialog, false)    /*** 在dialog里使用 */    @JvmStatic    fun with(act: Activity?, dialog: Dialog?, isOnly: Boolean) =      getRetriever().get(act, dialog, isOnly)    /*** 销毁Fragment */    @JvmStatic    fun destroy(fragment: Fragment?) {      getRetriever().destroy(fragment, false)    }    /*** 销毁Fragment */    @JvmStatic    fun destroy(fragment: Fragment?, isOnly: Boolean) {      getRetriever().destroy(fragment, isOnly)    }    /*** 销毁Fragment */    @JvmStatic    fun destroy(fragment: android.app.Fragment?) {      getRetriever().destroy(fragment, false)    }    /*** 销毁Fragment */    @JvmStatic    fun destroy(fragment: android.app.Fragment?, isOnly: Boolean) {      getRetriever().destroy(fragment, isOnly)    }    /*** 在Dialog里销毁，不包括DialogFragment */    @JvmStatic    fun destroy(act: Activity?, dialog: Dialog?) {      getRetriever().destroy(act, dialog, false)    }    /*** 在Dialog里销毁，不包括DialogFragment */    @JvmStatic    fun destroy(act: Activity?, dialog: Dialog?, isOnly: Boolean) {      getRetriever().destroy(act, dialog, isOnly)    }    /*** 判断手机是否支持状态栏字体变色 */    @JvmStatic    fun isSupportStatusBarDarkFont(): Boolean {      return OSUtils.isMIUI6Later()        || OSUtils.isFlymeOS4Later()        || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)    }    /*** 判断导航栏图标是否支持变色 */    @JvmStatic    fun isSupportNavigationIconDark(): Boolean {      return OSUtils.isMIUI6Later()        || OSUtils.isFlymeOS4Later()        || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)    }    /*** 为标题栏paddingTop和高度增加fixHeight的高度 */    @JvmStatic    fun setTitleBar(act: Activity?, fixHeight: Int, views: List<View?>) {      act ?: return      kotlin.runCatching {        val targetHeight = if (fixHeight < 0) 0 else fixHeight        for (view in views) {          if (null == view) continue          val fitsH = (view.getTag(R.id.immersion_fits_layout_overlap) as? Int?) ?: 0          if (fitsH != targetHeight) {            view.setTag(R.id.immersion_fits_layout_overlap, targetHeight)            val lp = view.layoutParams              ?: ViewGroup.LayoutParams(MATCH_PARENT, WRAP_CONTENT)            if (lp.height == WRAP_CONTENT || lp.height == MATCH_PARENT) {              view.post {                lp.height = view.height + targetHeight - fitsH                view.setPadding(                  view.paddingLeft,                  view.paddingTop + targetHeight - fitsH,                  view.paddingRight,                  view.paddingBottom                )                view.layoutParams = lp              }            } else {              lp.height = lp.height + targetHeight - fitsH              view.setPadding(                view.paddingLeft,                view.paddingTop + targetHeight - fitsH,                view.paddingRight,                view.paddingBottom              )              view.layoutParams = lp            }          }        }      }    }    @JvmStatic    fun setTitleBar(act: Activity?, views: List<View?>) {      setTitleBar(act, getStatusBarHeight(act), views)    }    @JvmStatic    fun setTitleBar(fragment: Fragment?, fixHeight: Int, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBar(act, fixHeight, views)    }    @JvmStatic    fun setTitleBar(fragment: Fragment?, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBar(act, views)    }    @JvmStatic    fun setTitleBar(fragment: android.app.Fragment?, fixHeight: Int, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBar(act, fixHeight, views)    }    @JvmStatic    fun setTitleBar(fragment: android.app.Fragment?, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBar(act, views)    }    /*** 为标题栏marginTop增加fixHeight的高度 */    @JvmStatic    fun setTitleBarMarginTop(act: Activity?, fixHeight: Int, views: List<View?>) =      kotlin.runCatching {        act ?: return@runCatching        val targetHeight = if (fixHeight < 0) 0 else fixHeight        for (view in views) {          if (view == null) continue          val fitsH = (view.getTag(R.id.immersion_fits_layout_overlap) as? Int?) ?: 0          if (fitsH != targetHeight) {            view.setTag(R.id.immersion_fits_layout_overlap, targetHeight)            val lp = view.layoutParams              ?: ViewGroup.MarginLayoutParams(MATCH_PARENT, WRAP_CONTENT)            (lp as? ViewGroup.MarginLayoutParams?)?.let {              lp.setMargins(                lp.leftMargin,                lp.topMargin + targetHeight - fitsH,                lp.rightMargin,                lp.bottomMargin              )            }            view.layoutParams = lp          }        }      }    @JvmStatic    fun setTitleBarMarginTop(act: Activity?, view: List<View?>) {      setTitleBarMarginTop(act, getStatusBarHeight(act), view)    }    @JvmStatic    fun setTitleBarMarginTop(fragment: Fragment?, fixHeight: Int, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBarMarginTop(act, fixHeight, views)    }    @JvmStatic    fun setTitleBarMarginTop(fragment: Fragment?, views: List<View?>) {      setTitleBarMarginTop(fragment?.activity, views)    }    @JvmStatic    fun setTitleBarMarginTop(fragment: android.app.Fragment?, fixHeight: Int, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBarMarginTop(act, fixHeight, views)    }    @JvmStatic    fun setTitleBarMarginTop(fragment: android.app.Fragment?, views: List<View?>) {      val act = fragment?.activity ?: return      setTitleBarMarginTop(act, views)    }    /*** 单独在标题栏的位置增加view，高度为fixHeight的高度 */    @JvmStatic    fun setStatusBarView(act: Activity?, fixHeight: Int, views: List<View?>) {      act ?: return      kotlin.runCatching {        val targetHeight = if (fixHeight < 0) 0 else fixHeight        for (view in views) {          if (view == null) continue          val fitsH = (view.getTag(R.id.immersion_fits_layout_overlap) as? Int?) ?: 0          if (fitsH != targetHeight) {            view.setTag(R.id.immersion_fits_layout_overlap, targetHeight)            val lp = view.layoutParams              ?: ViewGroup.LayoutParams(MATCH_PARENT, 0)            lp.height = targetHeight            view.layoutParams = lp          }        }      }    }    @JvmStatic    fun setStatusBarView(act: Activity?, view: List<View?>) {      setStatusBarView(act, getStatusBarHeight(act), view)    }    @JvmStatic    fun setStatusBarView(fragment: Fragment?, fixHeight: Int, views: List<View?>) {      fragment ?: return      setStatusBarView(fragment.activity, fixHeight, views)    }    @JvmStatic    fun setStatusBarView(fragment: Fragment?, views: List<View?>) {      fragment ?: return      setStatusBarView(fragment.activity, views)    }    @JvmStatic    fun setStatusBarView(fragment: android.app.Fragment?, fixHeight: Int, views: List<View?>) {      fragment ?: return      setStatusBarView(fragment.activity, fixHeight, views)    }    @JvmStatic    fun setStatusBarView(fragment: android.app.Fragment?, views: List<View?>) {      fragment ?: return      setStatusBarView(fragment.activity, views)    }    /*** 调用系统view的setFitsSystemWindows方法 */    @JvmStatic    fun setFitsSystemWindows(act: Activity?, applySystemFits: Boolean) {      act ?: return      kotlin.runCatching {        val content = act.findViewById<ViewGroup>(android.R.id.content).getChildAt(0)        setFitsSystemWindows(content, applySystemFits)      }    }    @JvmStatic    fun setFitsSystemWindows(fragment: Fragment?, applySystemFits: Boolean) {      setFitsSystemWindows(fragment?.activity, applySystemFits)    }    @JvmStatic    fun setFitsSystemWindows(fragment: android.app.Fragment?, applySystemFits: Boolean) {      setFitsSystemWindows(fragment?.activity, applySystemFits)    }    @JvmStatic    fun setFitsSystemWindows(act: Activity?) {      setFitsSystemWindows(act, true)    }    @JvmStatic    fun setFitsSystemWindows(fragment: Fragment?) {      setFitsSystemWindows(fragment?.activity)    }    @JvmStatic    fun setFitsSystemWindows(fragment: android.app.Fragment?) {      setFitsSystemWindows(fragment?.activity)    }    @JvmStatic    fun setFitsSystemWindows(view: View?, applySystemFits: Boolean) {      view ?: return      if (view is ViewGroup) {        if (view is DrawerLayout) {          setFitsSystemWindows(view.getChildAt(0), applySystemFits)        } else {          view.fitsSystemWindows = applySystemFits          view.clipToPadding = true        }      } else view.fitsSystemWindows = applySystemFits    }    /*** 检查布局根节点是否使用了android:fitsSystemWindows="true"属性 */    @JvmStatic    fun checkFitsSystemWindows(view: View?): Boolean {      view ?: return false      if (view.fitsSystemWindows) {        return true      }      if (view is ViewGroup) {        for (i in 0 until view.childCount) {          val child = view.getChildAt(i)          if (child is DrawerLayout) {            if (checkFitsSystemWindows(child)) {              return true            }          }          if (child.fitsSystemWindows) {            return true          }        }      }      return false    }    /*** 是否存在导航条*/    @JvmStatic    fun hasNavigationBar(act: Activity?): Boolean {      act ?: return false      val config = BarConfig(act)      return config.mHasNavigationBar    }    @JvmStatic    fun hasNavigationBar(fragment: Fragment?): Boolean {      return hasNavigationBar(fragment?.activity)    }    @JvmStatic    fun hasNavigationBar(fragment: android.app.Fragment?): Boolean {      return hasNavigationBar(fragment?.activity)    }    @JvmStatic    fun hasNavigationBar(context: Context?): Boolean {      return getNavigationBarHeight(context) > 0    }    /*** 导航条高度*/    @JvmStatic    fun getNavigationBarHeight(act: Activity?): Int {      act ?: return 0      val config = BarConfig(act)      return config.mNavigationBarHeight    }    @JvmStatic    fun getNavigationBarHeight(fragment: Fragment?): Int {      return getNavigationBarHeight(fragment?.activity)    }    @JvmStatic    fun getNavigationBarHeight(fragment: android.app.Fragment?): Int {      return getNavigationBarHeight(fragment?.activity)    }    @JvmStatic    fun getNavigationBarHeight(context: Context?): Int {      context ?: return 0      val bean = GestureUtils.getGestureBean(context)      if (bean.isGesture && bean.checkNavigation.not()) {        return 0      }      return BarConfig.getNavigationBarHeightInternal(context)    }    /*** 导航条的宽度*/    @JvmStatic    fun getNavigationBarWidth(act: Activity?): Int {      act ?: return 0      val config = BarConfig(act)      return config.mNavigationBarWidth    }    @JvmStatic    fun getNavigationBarWidth(fragment: Fragment?): Int {      return getNavigationBarWidth(fragment?.activity)    }    @JvmStatic    fun getNavigationBarWidth(fragment: android.app.Fragment?): Int {      return getNavigationBarWidth(fragment?.activity)    }    @JvmStatic    fun getNavigationBarWidth(context: Context?): Int {      context ?: return 0      val bean = GestureUtils.getGestureBean(context)      if (bean.isGesture && bean.checkNavigation.not()) {        return 0      }      return BarConfig.getNavigationBarWidthInternal(context)    }    /*** 导航条是否在底部 */    @JvmStatic    fun isNavigationAtBottom(act: Activity?): Boolean {      act ?: return true      val config = BarConfig(act)      return config.isNavigationAtBottom()    }    @JvmStatic    fun isNavigationAtBottom(fragment: Fragment?): Boolean {      return isNavigationAtBottom(fragment?.activity)    }    @JvmStatic    fun isNavigationAtBottom(fragment: android.app.Fragment?): Boolean {      return isNavigationAtBottom(fragment?.activity)    }    /*** 获取顶部状态栏高度*/    @JvmStatic    fun getStatusBarHeight(act: Activity?): Int {      act ?: return 0      val config = BarConfig(act)      return config.mStatusBarHeight    }    @JvmStatic    fun getStatusBarHeight(fragment: Fragment?): Int {      return getStatusBarHeight(fragment?.activity)    }    @JvmStatic    fun getStatusBarHeight(fragment: android.app.Fragment?): Int {      return getStatusBarHeight(fragment?.activity)    }    @JvmStatic    fun getStatusBarHeight(context: Context?): Int {      context ?: return 0      return BarConfig.getInternalDimensionSize(        context,        Constants.IMMERSE_STATUS_BAR_HEIGHT      )    }    /*** 获取 ActionBar 的高度 */    @JvmStatic    fun getActionBarHeight(act: Activity?): Int {      act ?: return 0      val config = BarConfig(act)      return config.mActionBarHeight    }    @JvmStatic    fun getActionBarHeight(fragment: Fragment?): Int {      return getActionBarHeight(fragment?.activity)    }    @JvmStatic    fun getActionBarHeight(fragment: android.app.Fragment?): Int {      return getActionBarHeight(fragment?.activity)    }    /*** 是否是刘海屏 */    @JvmStatic    fun hasNotchScreen(act: Activity?): Boolean {      return Notches.notchScreen(act)    }    @JvmStatic    fun hasNotchScreen(fragment: Fragment?): Boolean {      return Notches.notchScreen(fragment?.activity)    }    @JvmStatic    fun hasNotchScreen(fragment: android.app.Fragment?): Boolean {      return Notches.notchScreen(fragment?.activity)    }    @JvmStatic    fun hasNotchScreen(view: View?): Boolean {      return Notches.notchScreen(view)    }    @JvmStatic    fun getNotchHeight(fragment: Fragment?): Int {      return getNotchHeight(fragment?.activity)    }    @JvmStatic    fun getNotchHeight(fragment: android.app.Fragment?): Int {      return getNotchHeight(fragment?.activity)    }    @JvmStatic    fun getNotchHeight(fragment: Fragment?, callback: NotchCallback?) {      getNotchHeight(fragment?.activity, callback)    }    @JvmStatic    fun getNotchHeight(fragment: android.app.Fragment?, callback: NotchCallback?) {      return getNotchHeight(fragment?.activity, callback)    }    @JvmStatic    fun getNotchHeight(act: Activity?): Int {      return Notches.notchHeight(act)    }    @JvmStatic    fun getNotchHeight(act: Activity?, callback: NotchCallback?) {      Notches.notchHeight(act, callback)    }    @JvmStatic    fun hideStatusBar(window: Window?) {      window?.setFlags(        WindowManager.LayoutParams.FLAG_FULLSCREEN,        WindowManager.LayoutParams.FLAG_FULLSCREEN      )    }    @JvmStatic    fun showStatusBar(window: Window?) {      window?.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)    }    @JvmStatic    fun isGesture(fragment: android.app.Fragment?): Boolean {      val ctx = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {        fragment?.context ?: return false      } else return false      return isGesture(ctx)    }    @JvmStatic    fun isGesture(fragment: Fragment?): Boolean {      val ctx = fragment?.context ?: return false      return isGesture(ctx)    }    /*** 是否是手势操作 */    @JvmStatic    fun isGesture(ctx: Context?): Boolean {      val gesture = GestureUtils.getGestureBean(ctx)      return gesture.isGesture    }    /******====== 内部私有方法 ======******/    private fun getRetriever() =      RequestManagerRetriever.instance    private fun isEmpty(str: String?): Boolean {      return str.isNullOrEmpty()        || str.trim().isEmpty()        || str.lowercase() == "null"    }  }  private lateinit var mAct: Activity  private var mSupportFragment: Fragment? = null  private var mFragment: android.app.Fragment? = null  private var mDialog: Dialog? = null  private var mWindow: Window? = null  private var mDecorView: ViewGroup? = null  private var mContentView: ViewGroup? = null  private var mParentBar: ImmerseBar? = null  /*** 是否是在Fragment里使用 */  private var mIsFragment = false  /*** 是否是DialogFragment */  private var mIsDialogFragment = false  /*** 是否是在Dialog里使用 */  private var mIsDialog = false  /*** 用户配置的bar参数 */  private var mBarParams: BarParams? = null  /*** 系统bar相关信息 */  private var mBarConfig: BarConfig? = null  /*** 软键盘监听相关 */  private var mFitsKeyboard: FitsKeyboard? = null  /*** 导航栏的高度，适配Emui3系统有用 */  private var mNavigationBarHeight = 0  /*** 导航栏的宽度，适配Emui3系统有用 */  private var mNavigationBarWidth = 0  /*** ActionBar的高度 */  private var mActionBarHeight = 0  /*** 当前顶部布局和状态栏重叠是以哪种方式适配的 */  private var mFitsStatusBarType = Constants.FLAG_FITS_DEFAULT  private var mPaddingLeft = 0  private var mPaddingTop = 0  private var mPaddingRight = 0  private var mPaddingBottom = 0  /*** 是否已经调用过init()方法了 */  private var mInitialized = false  /*** ActionBar是否是在LOLLIPOP下设备使用 */  private var mIsActionBarBelowLOLLIPOP = false  private var mKeyboardTempEnable = false  /*** 用户使用tag增加的bar参数的集合 */  private val mTagMap: HashMap<String, BarParams> = HashMap()  /*** 在 Activity 里初始化 */  constructor(act: Activity?) : super() {    mAct = act ?: return    initCommonParameter(mAct.window)  }  /*** 在 Fragment 里初始化 */  constructor(fragment: Fragment?) : super() {    mAct = fragment?.activity ?: return    mIsFragment = true    mSupportFragment = fragment    checkInitWithActivity()    initCommonParameter(mAct.window)  }  /*** 在 android.app.Fragment 里初始化 */  constructor(fragment: android.app.Fragment?) : super() {    mAct = fragment?.activity ?: return    mIsFragment = true    mFragment = fragment    checkInitWithActivity()    initCommonParameter(mAct.window)  }  /*** 在 DialogFragment 里初始化 */  constructor(dialogFragment: DialogFragment?) : super() {    mAct = dialogFragment?.activity ?: return    mIsDialog = true    mIsDialogFragment = true    mSupportFragment = dialogFragment    mDialog = dialogFragment.dialog    checkInitWithActivity()    initCommonParameter(mDialog?.window)  }  /*** 在 android.app.DialogFragment 里初始化 */  constructor(dialogFragment: android.app.DialogFragment?) : super() {    mAct = dialogFragment?.activity ?: return    mIsDialog = true    mIsDialogFragment = true    mFragment = dialogFragment    mDialog = dialogFragment.dialog    checkInitWithActivity()    initCommonParameter(mDialog?.window)  }  /*** 在Dialog里初始化 */  constructor(act: Activity?, dialog: Dialog?) : super() {    mAct = act ?: return    mIsDialog = true    mDialog = dialog    checkInitWithActivity()    initCommonParameter(mDialog?.window)  }  fun init() {    val params = mBarParams ?: return    if (params.barEnable) {      updateBarParams() //更新Bar的参数      setBar()          //设置沉浸式      fitsWindows()     //修正界面显示      fitsKeyboard()    //适配软键盘与底部输入框冲突问题      transformView()   //变色view      mInitialized = true    }  }  /*** 初始化状态栏和导航栏 */  fun setBar() {    //防止系统栏隐藏时内容区域大小发生变化    var uiFlags = View.SYSTEM_UI_FLAG_LAYOUT_STABLE    if (OSUtils.isEMUI3_x().not()) {      //适配刘海屏      fitsNotchScreen()      //初始化5.0以上，包含5.0      uiFlags = initBarAboveLOLLIPOP(uiFlags)      //android 6.0以上设置状态栏字体为暗色      uiFlags = setStatusBarDarkFont(uiFlags)      //android 8.0以上设置导航栏图标为暗色      uiFlags = setNavigationIconDark(uiFlags)      //适配android 11以上      setBarDarkFontAboveR()    } else {      //初始化5.0以下，4.4以上沉浸式      initBarBelowLOLLIPOP()    }    //隐藏状态栏或者导航栏    uiFlags = hideBarBelowR(uiFlags)    //应用flag    mDecorView?.systemUiVisibility = uiFlags    //适配小米和魅族状态栏黑白    setSpecialBarDarkMode()    //适配android 11以上    hideBarAboveR()    //导航栏显示隐藏监听，目前只支持带有导航栏的华为和小米手机    if (mBarParams?.onNavigationBarListener != null) {      NavigationBarObserver.instance.register(mAct.application);    }  }  /*** 更新Bar的参数 */  private fun updateBarParams() {    adjustDarkModeParams()    if (mInitialized.not() || mIsFragment) {      updateBarConfig()    }    mParentBar?.let {      if (mIsFragment) {        //如果在Fragment中使用，让Activity同步Fragment的BarParams参数        it.mBarParams = mBarParams      }      if (mIsDialog && it.mKeyboardTempEnable) {        //如果dialog里设置了keyboardEnable为true，则Activity中所设置的keyboardEnable为false        it.mBarParams?.keyboardEnable = false      }    }  }  /*** 修正界面显示 */  private fun fitsWindows() {    if (OSUtils.isEMUI3_x().not()) {      //android 5.0以上解决状态栏和布局重叠问题      fitsWindowsAboveLOLLIPOP()    } else {      //android 5.0以下解决状态栏和布局重叠问题      fitsWindowsBelowLOLLIPOP()    }    //适配状态栏与布局重叠问题    fitsLayoutOverlap()  }  /*** 解决底部输入框与软键盘问题 */  private fun fitsKeyboard() {    if (mIsFragment.not()) {      if (mBarParams?.keyboardEnable == true) {        if (mFitsKeyboard == null) {          mFitsKeyboard = FitsKeyboard(this)        }        mFitsKeyboard?.enable(mBarParams?.keyboardMode)      } else {        mFitsKeyboard?.disable()      }    } else {      mParentBar ?: return      if (mParentBar?.mBarParams?.keyboardEnable == true) {        if (mParentBar?.mFitsKeyboard == null) {          mParentBar?.mFitsKeyboard = FitsKeyboard(mParentBar)        }        mParentBar?.mFitsKeyboard?.enable(mParentBar?.mBarParams?.keyboardMode)      } else {        mParentBar?.mFitsKeyboard?.disable()      }    }  }  /*** 变色 view */  private fun transformView() {    val params = mBarParams ?: return    if (params.viewMap.isEmpty()) return    kotlin.runCatching {      val entrySet = params.viewMap.entries      for ((view, map) in entrySet) {        var colorBefore = params.statusBarColor        var colorAfter = params.statusBarColorTransform        for ((first, second) in map.entries) {          colorBefore = first          colorAfter = second        }        if (view != null) {          if (abs(params.viewAlpha - 0.0f) == 0f) {            view.setBackgroundColor(ColorUtils.blendARGB(colorBefore, colorAfter, params.statusBarAlpha))          } else {            view.setBackgroundColor(ColorUtils.blendARGB(colorBefore, colorAfter, params.viewAlpha))          }        }      }    }  }  /*** 调整深色亮色模式参数 */  private fun adjustDarkModeParams() {    val params = mBarParams ?: return    val statusBarColor = ColorUtils.blendARGB(      params.statusBarColor,      params.statusBarColorTransform, params.statusBarAlpha    )    if (params.autoStatusBarDarkModeEnable && statusBarColor != Color.TRANSPARENT) {      val darkFont = statusBarColor > IMMERSE_BOUNDARY_COLOR      statusBarDarkFont(darkFont, params.autoStatusBarDarkModeAlpha)    }    val navigationBarColor = ColorUtils.blendARGB(      params.navigationBarColor,      params.navigationBarColorTransform, params.navigationBarAlpha    )    if (params.autoNavigationBarDarkModeEnable && navigationBarColor != Color.TRANSPARENT) {      val darkIcon = navigationBarColor > IMMERSE_BOUNDARY_COLOR      navigationBarDarkIcon(darkIcon, params.autoNavigationBarDarkModeAlpha)    }  }  /*** 更新BarConfig */  private fun updateBarConfig() {    mBarConfig = BarConfig(mAct)    if ((mInitialized.not() || mIsActionBarBelowLOLLIPOP)) {      mActionBarHeight = mBarConfig?.mActionBarHeight ?: 0    }  }  /*** 适配刘海屏 */  private fun fitsNotchScreen() {    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P      && mInitialized.not()    ) {      kotlin.runCatching {        val lp = mWindow?.attributes ?: return        lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams          .LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES        mWindow?.attributes = lp      }    }  }  /*** 初始化android 5.0以上状态栏和导航栏 */  private fun initBarAboveLOLLIPOP(uiFlags: Int): Int {    val params = mBarParams ?: return uiFlags    val window = mWindow ?: return uiFlags    var sourceFlags = uiFlags    //获得默认导航栏颜色    if (mInitialized.not()) {      params.defaultNavigationBarColor = window.navigationBarColor    }    //Activity全屏显示，但状态栏不会被隐藏覆盖，状态栏依然可见，Activity顶端布局部分会被状态栏遮住。    sourceFlags = sourceFlags or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN    if (params.fullScreen && params.navigationBarEnable) {      //Activity全屏显示，但导航栏不会被隐藏覆盖，导航栏依然可见，Activity底部布局部分会被导航栏遮住。      sourceFlags = sourceFlags or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION    }    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)    //判断是否存在导航栏    if (mBarConfig?.mHasNavigationBar == true) {      window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)    }    //需要设置这个才能设置状态栏和导航栏颜色    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)    //设置状态栏颜色    if (params.statusBarColorEnabled) {      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {        window.isStatusBarContrastEnforced = false      }      window.statusBarColor = ColorUtils.blendARGB(        params.statusBarColor,        params.statusBarColorTransform, params.statusBarAlpha      )    } else {      window.statusBarColor = ColorUtils.blendARGB(        params.statusBarColor,        Color.TRANSPARENT, params.statusBarAlpha      )    }    //设置导航栏颜色    if (params.navigationBarEnable) {      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {        window.isNavigationBarContrastEnforced = false      }      window.navigationBarColor = ColorUtils.blendARGB(        params.navigationBarColor,        params.navigationBarColorTransform, params.navigationBarAlpha      )    } else {      window.navigationBarColor = params.defaultNavigationBarColor    }    return sourceFlags  }  /*** 设置状态栏字体颜色 */  private fun setStatusBarDarkFont(uiFlags: Int): Int {    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {      if (mBarParams?.statusBarDarkFont == true) {        uiFlags or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;      } else uiFlags    } else uiFlags  }  /*** 设置导航栏图标亮色与暗色 */  private fun setNavigationIconDark(uiFlags: Int): Int {    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {      if (mBarParams?.navigationBarDarkIcon == true) {        uiFlags or View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR      } else uiFlags    } else uiFlags  }  /*** 设置状态栏和导航栏字体与图标颜色 */  private fun setBarDarkFontAboveR() {    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {      setStatusBarDarkFontAboveR()      setNavigationIconDarkAboveR()    }  }  /*** 设置导航栏图标亮色与暗色 */  @RequiresApi(Build.VERSION_CODES.R)  private fun setNavigationIconDarkAboveR() {    val wic = mContentView?.windowInsetsController ?: return    if (mBarParams?.navigationBarDarkIcon == true) {      wic.setSystemBarsAppearance(        WindowInsetsController.APPEARANCE_LIGHT_NAVIGATION_BARS,        WindowInsetsController.APPEARANCE_LIGHT_NAVIGATION_BARS      )    } else {      wic.setSystemBarsAppearance(        0,        WindowInsetsController.APPEARANCE_LIGHT_NAVIGATION_BARS      )    }  }  /*** 设置状态栏图标亮色与暗色 */  @RequiresApi(Build.VERSION_CODES.R)  private fun setStatusBarDarkFontAboveR() {    val wic = mContentView?.windowInsetsController ?: return    if (mBarParams?.statusBarDarkFont == true) {      if (mWindow != null) {        unsetSystemUiFlag(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR)      }      wic.setSystemBarsAppearance(        WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS,        WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS      )    } else {      wic.setSystemBarsAppearance(        0,        WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS      )    }  }  /*** 重置系统UI参数 */  private fun unsetSystemUiFlag(flag: Int) {    val decorView = mWindow?.decorView ?: return    decorView.systemUiVisibility = (decorView.systemUiVisibility and flag.inv())  }  /*** 初始化 emui3.1 状态栏和导航栏 */  private fun initBarBelowLOLLIPOP() {    val window = mWindow ?: return    val config = mBarConfig ?: return    val params = mBarParams ?: return    //透明状态栏    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)    //创建一个假的状态栏    setupStatusBarView()    //判断是否存在导航栏，是否禁止设置导航栏    if (config.mHasNavigationBar || OSUtils.isEMUI3_x()) {      if (params.navigationBarEnable && params.navigationBarWithEMUI3Enable) {        //透明导航栏，设置这个，如果有导航栏，底部布局会被导航栏遮住        window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)      } else {        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)      }      if (0 == mNavigationBarHeight) {        mNavigationBarHeight = config.mNavigationBarHeight      }      if (0 == mNavigationBarWidth) {        mNavigationBarWidth = config.mNavigationBarWidth      }      //创建一个假的导航栏      setupNavBarView()    }  }  /*** 设置一个可以自定义颜色的导航栏 */  private fun setupNavBarView() {    val config = mBarConfig ?: return    val params = mBarParams ?: return    var navView = mDecorView?.findViewById<View>(IMMERSE_NAVIGATION_BAR_VIEW_ID)    if (null == navView) {      navView = View(mAct)      navView.id = IMMERSE_NAVIGATION_BAR_VIEW_ID      mDecorView?.addView(navView)    }    val lp: FrameLayout.LayoutParams    if (config.isNavigationAtBottom()) {      lp = FrameLayout.LayoutParams(        FrameLayout.LayoutParams.MATCH_PARENT,        config.mNavigationBarHeight      )      lp.gravity = Gravity.BOTTOM    } else {      lp = FrameLayout.LayoutParams(        config.mNavigationBarWidth,        FrameLayout.LayoutParams.MATCH_PARENT      )      lp.gravity = Gravity.END    }    navView.setLayoutParams(lp)    navView.setBackgroundColor(      ColorUtils.blendARGB(        params.navigationBarColor,        params.navigationBarColorTransform, params.navigationBarAlpha      )    )    if (params.navigationBarEnable      && params.navigationBarWithKitkatEnable      && params.hideNavigationBar.not()    ) {      navView.visibility = View.VISIBLE    } else {      navView.visibility = View.GONE    }  }  /*** 设置一个可以自定义颜色的状态栏 */  private fun setupStatusBarView() {    val params = mBarParams ?: return    var statusBarView = mDecorView?.findViewById<View>(IMMERSE_STATUS_BAR_VIEW_ID)    if (null == statusBarView) {      statusBarView = View(mAct)      val lp = FrameLayout.LayoutParams(        FrameLayout.LayoutParams.MATCH_PARENT,        mBarConfig?.mStatusBarHeight ?: 0      )      lp.gravity = Gravity.CENTER      statusBarView.setLayoutParams(lp)      statusBarView.visibility = View.VISIBLE      statusBarView.id = IMMERSE_STATUS_BAR_VIEW_ID      mDecorView?.addView(statusBarView)    }    if (params.statusBarColorEnabled) {      statusBarView.setBackgroundColor(        ColorUtils.blendARGB(          params.statusBarColor, params.statusBarColorTransform, params.statusBarAlpha        )      )    } else {      statusBarView.setBackgroundColor(        ColorUtils.blendARGB(          params.statusBarColor, Color.TRANSPARENT, params.statusBarAlpha        )      )    }  }  /*** 隐藏或显示状态栏和导航栏 */  private fun hideBarBelowR(uiFlags: Int): Int {    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {      return uiFlags    }    var sourceFlag = uiFlags    when (mBarParams?.barState) {      BarState.FLAG_HIDE_BAR -> {        sourceFlag = sourceFlag or (          View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION            or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION            or View.INVISIBLE)      }      BarState.FLAG_HIDE_STATUS_BAR -> {        sourceFlag = sourceFlag or (          View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN            or View.INVISIBLE)      }      BarState.FLAG_HIDE_NAVIGATION_BAR -> {        sourceFlag = sourceFlag or (          View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION            or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION)      }      BarState.FLAG_SHOW_BAR -> {        sourceFlag = sourceFlag or View.SYSTEM_UI_FLAG_VISIBLE      }      null -> Unit    }    return sourceFlag or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;  }  /*** 适配小米和魅族状态栏黑白 */  private fun setSpecialBarDarkMode() {    val params = mBarParams ?: return    if (OSUtils.isMIUI6Later()) {      //修改miui状态栏字体颜色      BarFontUtils.setMIUIBarDark(        mWindow,        IMMERSE_STATUS_BAR_DARK_MIUI,        params.statusBarDarkFont      )      //修改miui导航栏图标为黑色      if (params.navigationBarEnable) {        BarFontUtils.setMIUIBarDark(          mWindow,          IMMERSE_NAVIGATION_BAR_DARK_MIUI,          params.navigationBarDarkIcon        )      }    }    // 修改Flyme OS状态栏字体颜色    if (OSUtils.isFlymeOS4Later()) {      if (params.flymeOSStatusBarFontColor != 0) {        BarFontUtils.setStatusBarDarkIcon(mAct, params.flymeOSStatusBarFontColor)      } else {        BarFontUtils.setStatusBarDarkIcon(mAct, params.statusBarDarkFont)      }    }  }  /*** 适配 android 11 以上状态栏和导航栏 */  private fun hideBarAboveR() {    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {      val wic = mContentView?.windowInsetsController ?: return      when (mBarParams?.barState) {        BarState.FLAG_HIDE_BAR -> {          wic.hide(WindowInsets.Type.statusBars())          wic.hide(WindowInsets.Type.navigationBars())        }        BarState.FLAG_HIDE_STATUS_BAR -> {          wic.hide(WindowInsets.Type.statusBars())        }        BarState.FLAG_HIDE_NAVIGATION_BAR -> {          wic.hide(WindowInsets.Type.navigationBars())        }        BarState.FLAG_SHOW_BAR -> {          wic.show(WindowInsets.Type.statusBars())          wic.show(WindowInsets.Type.navigationBars())        }        null -> Unit      }      wic.systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE    }  }  /*** Android 5.0 以上解决状态栏和布局重叠问题 */  private fun fitsWindowsAboveLOLLIPOP() {    if (checkFitsSystemWindows(mDecorView?.findViewById(android.R.id.content))) {      setPadding(0, 0, 0, 0)      return    }    val params = mBarParams ?: return    var top = 0    if (params.fits && mFitsStatusBarType == FLAG_FITS_SYSTEM_WINDOWS) {      top = mBarConfig?.mStatusBarHeight ?: 0    }    if (params.isSupportActionBar) {      top = (mBarConfig?.mStatusBarHeight ?: 0) + mActionBarHeight    }    setPadding(0, top, 0, 0)  }  /*** Android 5.0 以下解决状态栏和布局重叠问题 */  private fun fitsWindowsBelowLOLLIPOP() {    if (mBarParams?.isSupportActionBar == true) {      mIsActionBarBelowLOLLIPOP = true      mContentView?.post(this)    } else {      mIsActionBarBelowLOLLIPOP = false      postFitsWindowsBelowLOLLIPOP()    }  }  private fun postFitsWindowsBelowLOLLIPOP() {    //解决 android4.4 有导航栏的情况下，activity 底部被导航栏遮挡的问题和 android 5.0 以下解决状态栏和布局重叠问题    fitsWindowsKITKAT()    //解决华为 emui3.1 或者 3.0 导航栏手动隐藏的问题    if (!mIsFragment && OSUtils.isEMUI3_x()) {      fitsWindowsEMUI()    }  }  /*** 注册 emui3.x 导航栏监听函数 */  private fun fitsWindowsEMUI() {    val navView = mDecorView?.findViewById<View>(IMMERSE_NAVIGATION_BAR_VIEW_ID)    if (mBarParams?.navigationBarEnable == true      && mBarParams?.navigationBarWithKitkatEnable == true    ) {      if (navView != null) {        EMUI3NavigationBarObserver.instance.addNavbarListener(this)        EMUI3NavigationBarObserver.instance.register(mAct.application)      }    } else {      EMUI3NavigationBarObserver.instance.removeNavbarListener(this)      navView?.visibility = View.GONE    }  }  /*** 解决 android4.4 有导航栏的情况下，   * activity 底部被导航栏遮挡的问题和   * android 5.0 以下解决状态栏和布局重叠问题   **/  private fun fitsWindowsKITKAT() {    if (checkFitsSystemWindows(mContentView?.findViewById(android.R.id.content))) {      setPadding(0, 0, 0, 0)      return    }    val params = mBarParams ?: return    val config = mBarConfig ?: return    var top = 0    var right = 0    var bottom = 0    if (params.fits && mFitsStatusBarType == FLAG_FITS_SYSTEM_WINDOWS) {      top = config.mStatusBarHeight    }    if (params.isSupportActionBar) {      top = config.mStatusBarHeight + mActionBarHeight    }    if (config.mHasNavigationBar      && params.navigationBarEnable      && params.navigationBarWithKitkatEnable    ) {      if (params.fullScreen.not()) {        if (config.isNavigationAtBottom()) {          bottom = config.mNavigationBarHeight        } else {          right = config.mNavigationBarWidth        }      }      if (params.hideNavigationBar) {        if (config.isNavigationAtBottom()) {          bottom = 0        } else {          right = 0        }      } else {        if (config.isNavigationAtBottom().not()) {          right = config.mNavigationBarWidth        }      }    }    setPadding(0, top, right, bottom)  }  /*** 设置内边距 */  private fun setPadding(left: Int, top: Int, right: Int, bottom: Int) {    mContentView?.setPadding(left, top, right, bottom)    mPaddingLeft = left    mPaddingTop = top    mPaddingRight = right    mPaddingBottom = bottom  }  /*** 适配状态栏与布局重叠问题 */  private fun fitsLayoutOverlap() {    var fixHeight = 0    if (mBarParams?.fitsLayoutOverlapEnable == true) {      fixHeight = mBarConfig?.mStatusBarHeight ?: 0    }    when (mFitsStatusBarType) {      FLAG_FITS_TITLE -> {        //通过设置 paddingTop 重新绘制标题栏高度        setTitleBar(mAct, fixHeight, listOf(mBarParams?.titleBarView))      }      FLAG_FITS_TITLE_MARGIN_TOP -> {        //通过设置marginTop重新绘制标题栏高度        setTitleBarMarginTop(mAct, fixHeight, listOf(mBarParams?.titleBarView))      }      FLAG_FITS_STATUS -> {        //通过状态栏高度动态设置状态栏布局        setStatusBarView(mAct, fixHeight, listOf(mBarParams?.statusBarView))      }    }  }  /*** 是否已经调用过init()方法了 */  fun initialized() = mInitialized  fun isDialogFragment() = mIsDialogFragment  fun isFragment() = mIsFragment  fun getFragment() = mFragment  fun getSupportFragment() = mSupportFragment  fun getWindow() = mWindow  fun getDecorView() = mDecorView  fun getContentView() = mContentView  fun getActivity() = mAct  fun getPaddingBottom() = mPaddingBottom  fun getPaddingLeft() = mPaddingLeft  fun getPaddingRight() = mPaddingRight  fun getPaddingTop() = mPaddingTop  /*** 获取 Bar 参数 */  fun getBarParams() = mBarParams  /*** 获取 Bar 配置*/  fun getBarConfig() = mBarConfig ?: BarConfig(mAct)  fun getActionBarHeight() = mActionBarHeight  fun fitsParentBarKeyboard() {    mParentBar?.mFitsKeyboard?.let {      it.disable()      it.resetKeyboardHeight()    }  }  /*** 状态栏字体深色或亮色，判断设备支不支持状态栏变色来设置状态栏透明度 */  fun statusBarDarkFont(    darkFont: Boolean,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    val params = mBarParams ?: return this    params.statusBarDarkFont = darkFont    if (darkFont && isSupportStatusBarDarkFont().not()) {      params.statusBarAlpha = alpha    } else {      params.flymeOSStatusBarFontColor = params.flymeOSStatusBarFontTempColor      params.statusBarAlpha = params.statusBarTempAlpha    }    return this  }  /***   * 导航栏图标深色或亮色，只支持android o以上版本，   * 判断设备支不支持导航栏图标变色来设置导航栏透明度   * */  fun navigationBarDarkIcon(    darkIcon: Boolean,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    val params = mBarParams ?: return this    if (darkIcon && isSupportNavigationIconDark().not()) {      params.navigationBarAlpha = alpha    } else {      params.navigationBarAlpha = params.navigationBarTempAlpha    }    return this  }  /*** 透明状态栏，默认透明 */  fun transparentStatusBar(): ImmerseBar {    mBarParams?.statusBarColor = Color.TRANSPARENT    return this  }  /*** 透明导航栏，默认透明 */  fun transparentNavigationBar(): ImmerseBar {    mBarParams?.navigationBarColor = Color.TRANSPARENT    mBarParams?.fullScreen = true    return this  }  /*** 透明状态栏和导航栏 */  fun transparentBar(): ImmerseBar {    mBarParams?.statusBarColor = Color.TRANSPARENT    mBarParams?.navigationBarColor = Color.TRANSPARENT    mBarParams?.fullScreen = true    return this  }  /*** 设置状态栏颜色 */  fun statusBarColor(@ColorRes color: Int): ImmerseBar {    return this.statusBarColorInt(ContextCompat.getColor(mAct, color))  }  /*** 设置状态栏颜色+透明度 */  fun statusBarColor(    @ColorRes color: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.statusBarColorInt(ContextCompat.getColor(mAct, color), alpha)  }  /*** 设置状态栏颜色 */  fun statusBarColor(    @ColorRes color: Int,    @ColorRes colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.statusBarColorInt(      ContextCompat.getColor(mAct, color),      ContextCompat.getColor(mAct, colorTransform),      alpha    )  }  /*** 设置状态栏颜色 */  fun statusBarColor(color: String): ImmerseBar {    return this.statusBarColorInt(Color.parseColor(color))  }  /*** 设置状态栏颜色+透明度 */  fun statusBarColor(    color: String,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.statusBarColorInt(Color.parseColor(color), alpha)  }  /*** 设置状态栏颜色 */  fun statusBarColor(    color: String,    colorTransform: String,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.statusBarColorInt(      Color.parseColor(color),      Color.parseColor(colorTransform),      alpha    )  }  /*** 设置状态栏颜色 */  fun statusBarColorInt(@ColorInt color: Int): ImmerseBar {    mBarParams?.statusBarColor = color    return this  }  /*** 设置状态栏颜色+透明度 */  fun statusBarColorInt(    @ColorInt color: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.statusBarColor = color    mBarParams?.statusBarAlpha = alpha    return this  }  /*** 设置状态栏颜色 */  fun statusBarColorInt(    @ColorInt color: Int,    @ColorInt colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.statusBarColor = color    mBarParams?.statusBarColorTransform = colorTransform    mBarParams?.statusBarAlpha = alpha    return this  }  /*** 设置导航栏颜色 */  fun navigationBarColor(@ColorRes color: Int): ImmerseBar {    return this.navigationBarColorInt(ContextCompat.getColor(mAct, color))  }  /*** 设置导航栏颜色 */  fun navigationBarColor(    @ColorRes color: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.navigationBarColorInt(ContextCompat.getColor(mAct, color), alpha)  }  /*** 设置导航栏颜色 */  fun navigationBarColor(    @ColorRes color: Int,    @ColorRes colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.navigationBarColorInt(      ContextCompat.getColor(mAct, color),      ContextCompat.getColor(mAct, colorTransform),      alpha    )  }  /*** 设置导航栏颜色 */  fun navigationBarColor(color: String): ImmerseBar {    return this.navigationBarColorInt(Color.parseColor(color))  }  /*** 设置导航栏颜色 */  fun navigationBarColor(    color: String,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.navigationBarColorInt(Color.parseColor(color), alpha)  }  /*** 设置导航栏颜色 */  fun navigationBarColor(    color: String,    colorTransform: String,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.navigationBarColorInt(      Color.parseColor(color),      Color.parseColor(colorTransform),      alpha    )  }  /*** 设置导航栏颜色 */  fun navigationBarColorInt(@ColorInt color: Int): ImmerseBar {    mBarParams?.navigationBarColor = color    return this  }  /*** 设置导航栏颜色 */  fun navigationBarColorInt(    @ColorInt color: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.navigationBarColor = color    mBarParams?.navigationBarAlpha = alpha    return this  }  /*** 设置导航栏颜色 */  fun navigationBarColorInt(    @ColorInt color: Int,    @ColorInt colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.navigationBarColor = color    mBarParams?.navigationBarColorTransform = colorTransform    mBarParams?.navigationBarAlpha = alpha    return this  }  /*** 设置状态栏和导航栏颜色 */  fun barColor(@ColorRes color: Int): ImmerseBar {    return this.barColorInt(ContextCompat.getColor(mAct, color))  }  /*** 设置状态栏和导航栏颜色 */  fun barColor(    @ColorRes color: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.barColorInt(ContextCompat.getColor(mAct, color), alpha)  }  /*** 设置状态栏和导航栏颜色 */  fun barColor(    @ColorRes color: Int,    @ColorRes colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.barColorInt(      ContextCompat.getColor(mAct, color),      ContextCompat.getColor(mAct, colorTransform),      alpha    )  }  /*** 设置状态栏和导航栏颜色 */  fun barColor(color: String): ImmerseBar {    return this.barColorInt(Color.parseColor(color))  }  /*** 设置状态栏和导航栏颜色 */  fun barColor(    color: String,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.barColorInt(Color.parseColor(color), alpha)  }  /*** 设置状态栏和导航栏颜色 */  fun barColor(    color: String,    colorTransform: String,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return this.barColorInt(      Color.parseColor(color),      Color.parseColor(colorTransform),      alpha    )  }  /*** 设置状态栏和导航栏颜色 */  fun barColorInt(@ColorInt color: Int): ImmerseBar {    mBarParams?.statusBarColor = color    mBarParams?.navigationBarColor = color    return this  }  /*** 设置状态栏和导航栏颜色 */  fun barColorInt(    @ColorInt color: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.statusBarAlpha = alpha    mBarParams?.navigationBarColor = color    mBarParams?.statusBarColor = color    mBarParams?.navigationBarAlpha = alpha    return this  }  /*** 设置状态栏和导航栏颜色 */  fun barColorInt(    @ColorInt color: Int,    @ColorInt colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.statusBarColor = color    mBarParams?.navigationBarColor = color    mBarParams?.statusBarColorTransform = color    mBarParams?.navigationBarColorTransform = colorTransform    mBarParams?.statusBarAlpha = alpha    mBarParams?.navigationBarAlpha = alpha    return this  }  /*** 状态栏根据透明度最后变换成的颜色 */  fun statusBarColorTransform(@ColorRes colorTransform: Int): ImmerseBar {    return this.statusBarColorTransformInt(ContextCompat.getColor(mAct, colorTransform))  }  /*** 状态栏根据透明度最后变换成的颜色 */  fun statusBarColorTransform(colorTransform: String): ImmerseBar {    return this.statusBarColorTransformInt(Color.parseColor(colorTransform))  }  /*** 状态栏根据透明度最后变换成的颜色 */  fun statusBarColorTransformInt(@ColorInt colorTransform: Int): ImmerseBar {    mBarParams?.statusBarColorTransform = colorTransform    return this  }  /*** 导航栏根据透明度最后变换成的颜色 */  fun navigationBarColorTransform(@ColorRes colorTransform: Int): ImmerseBar {    return this.navigationBarColorTransformInt(ContextCompat.getColor(mAct, colorTransform))  }  /*** 导航栏根据透明度最后变换成的颜色 */  fun navigationBarColorTransform(colorTransform: String): ImmerseBar {    return this.navigationBarColorTransformInt(Color.parseColor(colorTransform))  }  /*** 导航栏根据透明度最后变换成的颜色 */  fun navigationBarColorTransformInt(@ColorInt colorTransform: Int): ImmerseBar {    mBarParams?.navigationBarColorTransform = colorTransform    return this  }  /*** 状态栏和导航栏根据透明度最后变换成的颜色 */  fun barColorTransform(@ColorRes colorTransform: Int): ImmerseBar {    return this.barColorTransformInt(ContextCompat.getColor(mAct, colorTransform))  }  /*** 状态栏和导航栏根据透明度最后变换成的颜色 */  fun barColorTransform(colorTransform: String): ImmerseBar {    return this.barColorTransformInt(Color.parseColor(colorTransform))  }  /*** 状态栏和导航栏根据透明度最后变换成的颜色 */  fun barColorTransformInt(@ColorInt colorTransform: Int): ImmerseBar {    mBarParams?.statusBarColorTransform = colorTransform    mBarParams?.navigationBarColorTransform = colorTransform    return this  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColor(view: View?): ImmerseBar {    return this.addViewSupportTransformColorInt(      view, mBarParams?.statusBarColorTransform    )  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColor(    view: View?, @ColorRes colorAfter: Int  ): ImmerseBar {    return this.addViewSupportTransformColorInt(      view, ContextCompat.getColor(mAct, colorAfter)    )  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColor(    view: View?, @ColorRes colorBefore: Int, @ColorRes colorAfter: Int  ): ImmerseBar {    return this.addViewSupportTransformColorInt(      view,      ContextCompat.getColor(mAct, colorBefore),      ContextCompat.getColor(mAct, colorAfter)    )  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColor(    view: View?, colorAfter: String  ): ImmerseBar {    return this.addViewSupportTransformColorInt(      view,      Color.parseColor(colorAfter)    )  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColor(    view: View?, colorBefore: String, colorAfter: String  ): ImmerseBar {    return this.addViewSupportTransformColorInt(      view,      Color.parseColor(colorBefore),      Color.parseColor(colorAfter)    )  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColorInt(    view: View?, @ColorInt colorAfter: Int?  ): ImmerseBar {    if (view == null || colorAfter == null) return this    val params = mBarParams ?: return this    val map = HashMap<Int, Int>()    map[params.statusBarColor] = colorAfter    params.viewMap[view] = map    return this  }  /*** 添加颜色变换支持View */  fun addViewSupportTransformColorInt(    view: View?, @ColorInt colorBefore: Int, @ColorInt colorAfter: Int  ): ImmerseBar {    if (view == null) return this    val params = mBarParams ?: return this    val map = HashMap<Int, Int>()    map[colorBefore] = colorAfter    params.viewMap[view] = map    return this  }  /*** view透明度 */  fun viewAlpha(@FloatRange(from = 0.0, to = 1.0) alpha: Float): ImmerseBar {    mBarParams?.viewAlpha = alpha    return this  }  /*** 移除颜色渐变View */  fun removeSupportView(view: View?): ImmerseBar {    if (null == view) return this    val params = mBarParams ?: return this    val map = params.viewMap[view]    if (!map.isNullOrEmpty()) {      params.viewMap.remove(view)    }    return this  }  /*** 移除所有颜色渐变View */  fun removeSupportAllView(): ImmerseBar {    mBarParams?.viewMap?.clear()    return this  }  /*** 有导航栏的情况下，Activity是否全屏显示 */  fun fullScreen(fullScreen: Boolean): ImmerseBar {    mBarParams?.fullScreen = fullScreen    return this  }  /*** 状态栏透明度 */  fun statusBarAlpha(@FloatRange(from = 0.0, to = 1.0) alpha: Float): ImmerseBar {    mBarParams?.statusBarAlpha = alpha    mBarParams?.statusBarTempAlpha = alpha    return this  }  /*** 导航栏透明度 */  fun navigationBarAlpha(@FloatRange(from = 0.0, to = 1.0) alpha: Float): ImmerseBar {    mBarParams?.navigationBarAlpha = alpha    mBarParams?.navigationBarTempAlpha = alpha    return this  }  /*** 状态栏和导航栏透明度 */  fun barAlpha(@FloatRange(from = 0.0, to = 1.0) alpha: Float): ImmerseBar {    mBarParams?.statusBarAlpha = alpha    mBarParams?.statusBarTempAlpha = alpha    mBarParams?.navigationBarAlpha = alpha    mBarParams?.navigationBarTempAlpha = alpha    return this  }  /*** 是否启用自动根据StatusBar和NavigationBar颜色调整深色模式与亮色模式 */  fun autoDarkModeEnable(enable: Boolean): ImmerseBar {    return this.autoDarkModeEnable(enable, 0.2f)  }  /*** 是否启用自动根据StatusBar和NavigationBar颜色调整深色模式与亮色模式 */  fun autoDarkModeEnable(    enable: Boolean,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.autoStatusBarDarkModeEnable = enable    mBarParams?.autoStatusBarDarkModeAlpha = alpha    mBarParams?.autoNavigationBarDarkModeEnable = enable    mBarParams?.autoNavigationBarDarkModeAlpha = alpha    return this  }  /*** 是否启用自动根据StatusBar颜色调整深色模式与亮色模式 */  fun autoStatusBarDarkModeEnable(enable: Boolean): ImmerseBar {    return this.autoStatusBarDarkModeEnable(enable, 0.2f)  }  /*** 是否启用自动根据StatusBar颜色调整深色模式与亮色模式 */  fun autoStatusBarDarkModeEnable(    enable: Boolean,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.autoStatusBarDarkModeEnable = enable    mBarParams?.autoStatusBarDarkModeAlpha = alpha    return this  }  /*** 是否启用自动根据NavigationBar颜色调整深色模式与亮色模式 */  fun autoNavigationBarDarkModeEnable(enable: Boolean): ImmerseBar {    return this.autoNavigationBarDarkModeEnable(enable, 0.2f)  }  /*** 是否启用自动根据NavigationBar颜色调整深色模式与亮色模式 */  fun autoNavigationBarDarkModeEnable(    enable: Boolean,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    mBarParams?.autoNavigationBarDarkModeEnable = enable    mBarParams?.autoNavigationBarDarkModeAlpha = alpha    return this  }  /*** 状态栏字体深色或亮色 */  fun statusBarDarkFont(dark: Boolean): ImmerseBar {    return this.statusBarDarkFont(dark, 0.2f)  }  /*** 导航栏图标深色或亮色，只支持android o以上版本 */  fun navigationBarDarkIcon(dark: Boolean): ImmerseBar {    return navigationBarDarkIcon(dark, 0.2f)  }  /***   * 修改 Flyme OS系统手机状态栏字体颜色，   * 优先级高于statusBarDarkFont(boolean isDarkFont)方法   * */  fun flymeOSStatusBarFontColor(@ColorRes color: Int): ImmerseBar {    val params = mBarParams ?: return this    params.flymeOSStatusBarFontColor = ContextCompat.getColor(mAct, color)    params.flymeOSStatusBarFontTempColor = params.flymeOSStatusBarFontColor    return this  }  /***   * 修改 Flyme OS系统手机状态栏字体颜色，   * 优先级高于statusBarDarkFont(boolean isDarkFont)方法   * */  fun flymeOSStatusBarFontColor(color: String): ImmerseBar {    val params = mBarParams ?: return this    params.flymeOSStatusBarFontColor = Color.parseColor(color)    params.flymeOSStatusBarFontTempColor = params.flymeOSStatusBarFontColor    return this  }  /***   * 修改 Flyme OS系统手机状态栏字体颜色，   * 优先级高于statusBarDarkFont(boolean isDarkFont)方法   * */  fun flymeOSStatusBarFontColorInt(@ColorInt color: Int): ImmerseBar {    val params = mBarParams ?: return this    params.flymeOSStatusBarFontColor = color    params.flymeOSStatusBarFontTempColor = params.flymeOSStatusBarFontColor    return this  }  /*** 隐藏导航栏或状态栏 */  fun hideBar(barState: BarState): ImmerseBar {    val params = mBarParams ?: return this    params.barState = barState    if (OSUtils.isEMUI3_x()) {      params.hideNavigationBar =        (params.barState == BarState.FLAG_HIDE_NAVIGATION_BAR)          || (params.barState == BarState.FLAG_HIDE_BAR)    }    return this  }  /***   * 解决布局与状态栏重叠问题，   * 该方法将调用系统 view 的 setFitsSystemWindows 方法，   * 一但 window 已经 focus 再设置为 false 将不会生效，   * 默认不会使用该方法，   * 如果是渐变色状态栏和顶部图片请不要调用此方法或者设置为false   * */  fun applySystemFits(apply: Boolean): ImmerseBar {    mBarParams?.fitsLayoutOverlapEnable = !apply    setFitsSystemWindows(mAct, apply)    return this  }  /*** 解决布局与状态栏重叠问题 */  fun fitsSystemWindows(fits: Boolean): ImmerseBar {    mBarParams?.fits = fits    if (fits) {      if (mFitsStatusBarType == FLAG_FITS_DEFAULT) {        mFitsStatusBarType = FLAG_FITS_SYSTEM_WINDOWS      }    } else {      mFitsStatusBarType = FLAG_FITS_DEFAULT    }    return this  }  /*** 解决布局与状态栏重叠问题，支持侧滑返回 */  fun fitsSystemWindows(fits: Boolean, @ColorRes color: Int): ImmerseBar {    return fitsSystemWindowsInt(fits, ContextCompat.getColor(mAct, color))  }  /*** 解决布局与状态栏重叠问题，支持侧滑返回 */  fun fitsSystemWindows(    fits: Boolean,    @ColorRes color: Int,    @ColorRes colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    return fitsSystemWindowsInt(      fits,      ContextCompat.getColor(mAct, color),      ContextCompat.getColor(mAct, colorTransform),      alpha    )  }  /*** 解决布局与状态栏重叠问题，支持侧滑返回 */  fun fitsSystemWindowsInt(fits: Boolean, @ColorInt color: Int): ImmerseBar {    return fitsSystemWindowsInt(fits, color, Color.BLACK, 0.0f)  }  /*** 解决布局与状态栏重叠问题，支持侧滑返回 */  fun fitsSystemWindowsInt(    fits: Boolean,    @ColorInt color: Int,    @ColorInt colorTransform: Int,    @FloatRange(from = 0.0, to = 1.0) alpha: Float  ): ImmerseBar {    val params = mBarParams ?: return this    params.fits = fits    params.contentColor = color    params.contentColorTransform = colorTransform    params.contentAlpha = alpha    if (fits) {      if (mFitsStatusBarType == FLAG_FITS_DEFAULT) {        mFitsStatusBarType = FLAG_FITS_SYSTEM_WINDOWS      }    } else {      mFitsStatusBarType = FLAG_FITS_DEFAULT    }    mContentView?.setBackgroundColor(      ColorUtils.blendARGB(        params.contentColor,        params.contentColorTransform,        params.contentAlpha      )    )    return this  }  /***   * 是否可以修复状态栏与布局重叠，默认为true，   * 只适合 ImmersionBar#statusBarView，   *        ImmersionBar#titleBar，   *        ImmersionBar#titleBarMarginTop   * */  fun fitsLayoutOverlapEnable(enable: Boolean): ImmerseBar {    mBarParams?.fitsLayoutOverlapEnable = enable    return this  }  /*** 通过状态栏高度动态设置状态栏布局 */  fun statusBarView(view: View?): ImmerseBar {    view ?: return this    mBarParams?.statusBarView = view    if (mFitsStatusBarType == FLAG_FITS_DEFAULT) {      mFitsStatusBarType = FLAG_FITS_STATUS    }    return this  }  /*** 通过状态栏高度动态设置状态栏布局,只能在Activity中使用 */  fun statusBarView(@IdRes id: Int): ImmerseBar {    return statusBarView(mAct.findViewById(id))  }  /*** 通过状态栏高度动态设置状态栏布局 */  fun statusBarView(rootView: View?, @IdRes viewId: Int): ImmerseBar {    return statusBarView(rootView?.findViewById(viewId))  }  /*** 解决状态栏与布局顶部重叠 */  fun titleBar(view: View?): ImmerseBar {    return titleBar(view, true)  }  /*** 解决状态栏与布局顶部重叠 */  fun titleBar(@IdRes viewId: Int): ImmerseBar {    return titleBar(viewId, true)  }  /*** 解决状态栏与布局顶部重叠 */  fun titleBar(@IdRes viewId: Int, enable: Boolean): ImmerseBar {    return if (mSupportFragment != null && mSupportFragment?.view != null) {      titleBar(mSupportFragment?.view?.findViewById(viewId), enable)    } else if (mFragment != null && mFragment?.view != null) {      titleBar(mFragment?.view?.findViewById(viewId), enable)    } else {      titleBar(mAct.findViewById(viewId), enable)    }  }  /*** 解决状态栏与布局顶部重叠 */  fun titleBar(@IdRes viewId: Int, rootView: View?): ImmerseBar {    return titleBar(rootView?.findViewById(viewId), true)  }  /*** 解决状态栏与布局顶部重叠 */  fun titleBar(@IdRes viewId: Int, rootView: View?, enable: Boolean): ImmerseBar {    return titleBar(rootView?.findViewById(viewId), enable)  }  /*** 解决状态栏与布局顶部重叠 */  fun titleBar(view: View?, enable: Boolean): ImmerseBar {    if (view == null) return this    if (mFitsStatusBarType == FLAG_FITS_DEFAULT) {      mFitsStatusBarType = FLAG_FITS_TITLE    }    mBarParams?.titleBarView = view    mBarParams?.statusBarColorEnabled = enable    return this  }  /*** 绘制标题栏距离顶部的高度为状态栏的高度 */  fun titleBarMarginTop(@IdRes viewId: Int): ImmerseBar {    return if (mSupportFragment != null && mSupportFragment?.view != null) {      titleBarMarginTop(mSupportFragment?.view?.findViewById(viewId))    } else if (mFragment != null && mFragment?.view != null) {      titleBarMarginTop(mFragment?.view?.findViewById(viewId))    } else {      titleBarMarginTop(mAct.findViewById(viewId))    }  }  /*** 绘制标题栏距离顶部的高度为状态栏的高度 */  fun titleBarMarginTop(@IdRes viewId: Int, rootView: View?): ImmerseBar {    return titleBarMarginTop(rootView?.findViewById(viewId))  }  /*** 绘制标题栏距离顶部的高度为状态栏的高度 */  fun titleBarMarginTop(view: View?): ImmerseBar {    view ?: return this    if (mFitsStatusBarType == FLAG_FITS_DEFAULT) {      mFitsStatusBarType = FLAG_FITS_TITLE_MARGIN_TOP    }    mBarParams?.titleBarView = view    return this  }  /***   * 支持有actionBar的界面,   * 调用该方法，布局讲从actionBar下面开始绘制   * */  fun supportActionBar(isSupportActionBar: Boolean): ImmerseBar {    mBarParams?.isSupportActionBar = isSupportActionBar    return this  }  /*** 状态栏颜色渐变 */  fun statusBarColorEnable(enable: Boolean): ImmerseBar {    mBarParams?.statusBarColorEnabled = enable    return this  }  /*** 重置所有参数 */  fun reset(): ImmerseBar {    mBarParams = BarParams()    mFitsStatusBarType = FLAG_FITS_DEFAULT    return this  }  /*** 给某个页面设置tag来标识这页bar的属性 */  fun addTag(tag: String?): ImmerseBar {    if (tag.isNullOrEmpty()) return this    val params = mBarParams ?: return this    mTagMap[tag] = params.clone()    return this  }  /*** 根据 tag 恢复到某次调用时的参数 */  fun getTag(tag: String?): ImmerseBar {    if (tag.isNullOrEmpty()) return this    val params = mTagMap[tag]    if (params != null) {      mBarParams = params    }    return this  }  /*** 解决软键盘与底部输入框冲突问题 ，默认是false */  fun keyboardEnable(enable: Boolean): ImmerseBar {    return keyboardEnable(enable, mBarParams?.keyboardMode)  }  /*** 解决软键盘与底部输入框冲突问题 ，默认是false */  fun keyboardEnable(enable: Boolean, mode: Int?): ImmerseBar {    if (mode == null) return this    mBarParams?.keyboardEnable = enable    mBarParams?.keyboardMode = mode    mKeyboardTempEnable = enable    return this  }  /*** 修改键盘模式 */  fun keyboardMode(mode: Int): ImmerseBar {    mBarParams?.keyboardMode = mode    return this  }  /*** 软键盘弹出关闭的回调监听 */  fun setOnKeyboardListener(listener: OnKeyboardListener?): ImmerseBar {    if (mBarParams?.onKeyboardListener == null) {      mBarParams?.onKeyboardListener = listener    }    return this  }  /*** 导航栏显示隐藏监听器 */  fun setOnNavigationBarListener(listener: OnNavigationBarListener?): ImmerseBar {    if (listener != null) {      if (mBarParams?.onNavigationBarListener == null) {        mBarParams?.onNavigationBarListener = listener        NavigationBarObserver.instance.addNavbarListener(mBarParams?.onNavigationBarListener)      }    } else {      if (mBarParams?.onNavigationBarListener != null) {        NavigationBarObserver.instance.removeNavbarListener(mBarParams?.onNavigationBarListener)        mBarParams?.onNavigationBarListener = null      }    }    return this  }  /***   * Bar监听，第一次调用和横竖屏切换都会触发此方法，   * 比如可以解决横竖屏切换，横屏情况下，刘海屏遮挡布局的问题   * */  fun setOnBarListener(listener: OnBarListener?): ImmerseBar {    if (listener != null) {      if (mBarParams?.onBarListener == null) {        mBarParams?.onBarListener = listener      }    } else {      mBarParams?.onBarListener = null    }    return this  }  /***   * 是否可以修改导航栏颜色，默认为true   * 优先级 navigationBarEnable > navigationBarWithKitkatEnable > navigationBarWithEMUI3Enable   * */  fun navigationBarEnable(enable: Boolean): ImmerseBar {    mBarParams?.navigationBarEnable = enable    return this  }  /***   * 是否能修改华为emui3.1导航栏颜色，默认为true，   * 优先级 navigationBarEnable > navigationBarWithKitkatEnable > navigationBarWithEMUI3Enable   * */  fun navigationBarWithKitkatEnable(enable: Boolean): ImmerseBar {    mBarParams?.navigationBarWithKitkatEnable = enable    return this  }  /***   * 是否能修改华为emui3.1导航栏颜色，默认为true，   * 优先级 navigationBarEnable  > navigationBarWithKitkatEnable > navigationBarWithEMUI3Enable   * */  fun navigationBarWithEMUI3Enable(enable: Boolean): ImmerseBar {    //是否可以修改emui3系列手机导航栏    if (OSUtils.isEMUI3_x()) {      mBarParams?.navigationBarWithEMUI3Enable = enable      mBarParams?.navigationBarWithKitkatEnable = enable    }    return this  }  /***   *  是否可以使用沉浸式，   *  如果已经是true了，在改为false，   *  之前沉浸式效果不会消失，之后设置的沉浸式效果也不会生效   * */  fun barEnable(enable: Boolean): ImmerseBar {    mBarParams?.barEnable = enable    return this  }  /*** 更新状态 */  fun onResume() {    updateBarConfig()    if (mIsFragment.not() && mInitialized && mBarParams != null) {      if (OSUtils.isEMUI3_x() && mBarParams?.navigationBarWithEMUI3Enable == true) {        init()      } else {        if (mBarParams?.barState != BarState.FLAG_SHOW_BAR) {          setBar()        }      }    }  }  /*** 更新状态 */  fun onConfigurationChanged() {    updateBarConfig()    if (OSUtils.isEMUI3_x()) {      if (mInitialized        && mIsFragment.not()        && mBarParams?.navigationBarWithKitkatEnable == true      ) {        init()      } else {        fitsWindows()      }    } else {      fitsWindows()    }  }  /*** 回收资源*/  fun onDestroy() {    //取消监听    cancelListener()    if (mIsDialog && mParentBar != null) {      mParentBar?.let { bar ->        bar.mBarParams?.keyboardEnable = bar.mKeyboardTempEnable        if (bar.mBarParams?.barState != BarState.FLAG_SHOW_BAR) {          bar.setBar()        }      }    }    mInitialized = false  }  /*** 取消注册emui3.x导航栏监听函数和软键盘监听 */  private fun cancelListener() {    kotlin.runCatching {      if (::mAct.isInitialized.not()) return      if (mFitsKeyboard != null) {        mFitsKeyboard?.cancel()        mFitsKeyboard = null      }      EMUI3NavigationBarObserver.instance.removeNavbarListener(this)      NavigationBarObserver.instance.removeNavbarListener(mBarParams?.onNavigationBarListener)    }  }  private fun checkInitWithActivity() {    if (mParentBar == null) {      mParentBar = with(mAct)    }    mParentBar?.let {      if (it.initialized().not()) {        it.init()      }    }  }  private fun initCommonParameter(window: Window?) {    mWindow = window ?: return    mBarParams = BarParams()    mDecorView = window.decorView as ViewGroup    mContentView = mDecorView?.findViewById(android.R.id.content)  }  override fun onNavigationBarChange(show: Boolean, type: NavigationBarType) {    val navView = mDecorView      ?.findViewById<View>(IMMERSE_NAVIGATION_BAR_VIEW_ID)      ?: return    mBarConfig = BarConfig(mAct)    var bottom = mContentView?.paddingBottom ?: 0    var right = mContentView?.paddingRight ?: 0    if (show.not()) {      //导航键隐藏了      navView.visibility = View.GONE      bottom = 0      right = 0    } else {      //导航键显示了      navView.visibility = View.VISIBLE      if (checkFitsSystemWindows(mDecorView?.findViewById(android.R.id.content))) {        bottom = 0        right = 0      } else {        if (mNavigationBarHeight == 0) {          mNavigationBarHeight = mBarConfig?.mNavigationBarHeight ?: 0        }        if (mNavigationBarWidth == 0) {          mNavigationBarWidth = mBarConfig?.mNavigationBarWidth ?: 0        }        val hideBar = mBarParams?.hideNavigationBar ?: false        if (hideBar.not()) {          val lp = navView.layoutParams as FrameLayout.LayoutParams          if (mBarConfig?.isNavigationAtBottom() == true) {            lp.gravity = Gravity.BOTTOM            lp.height = mNavigationBarHeight            bottom = if (mBarParams?.fullScreen == true) 0 else mNavigationBarHeight            right = 0          } else {            lp.gravity = Gravity.END            lp.width = mNavigationBarWidth            bottom = 0            right = if (mBarParams?.fullScreen == true) 0 else mNavigationBarWidth          }          navView.layoutParams = lp        }      }    }    setPadding(0, mContentView?.paddingTop ?: 0, right, bottom)  }  override fun run() {    postFitsWindowsBelowLOLLIPOP()  }}class ImmerseDelegate : Runnable {  private var mImmerseBar: ImmerseBar? = null  private var mBarProperty: BarProperty? = null  private var mOnBarListener: OnBarListener? = null  private var mNotchHeight = 0  constructor(any: Any?) : super() {    when (any) {      is Activity -> {        if (mImmerseBar == null) {          mImmerseBar = ImmerseBar(any)        }      }      is Fragment -> {        if (null == mImmerseBar) {          mImmerseBar = if (any is DialogFragment) {            ImmerseBar(any)          } else {            ImmerseBar(any)          }        }      }      is android.app.Fragment -> {        if (null == mImmerseBar) {          mImmerseBar = if (any is android.app.DialogFragment) {            ImmerseBar(any)          } else {            ImmerseBar(any)          }        }      }    }  }  constructor(act: Activity?, dialog: Dialog?) : super() {    if (null == mImmerseBar) {      mImmerseBar = ImmerseBar(act, dialog)    }  }  fun get() = mImmerseBar  fun onActivityCreated(newConfig: Configuration?) {    barChanged(newConfig)  }  fun onResume() {    mImmerseBar?.onResume()  }  fun onDestroy() {    mBarProperty = null    mOnBarListener = null    mImmerseBar?.onDestroy()    mImmerseBar = null  }  fun onConfigurationChanged(newConfig: Configuration?) {    if (null != mImmerseBar) {      mImmerseBar?.onConfigurationChanged()      barChanged(newConfig)    }  }  /*** 横竖屏切换监听 */  private fun barChanged(newConfig: Configuration?) {    newConfig ?: return    val immerseBar = mImmerseBar ?: return    if (immerseBar.initialized()) {      mOnBarListener = immerseBar.getBarParams()?.onBarListener      mOnBarListener?.let {        val act = immerseBar.getActivity()        if (mBarProperty == null) mBarProperty = BarProperty()        mBarProperty?.portrait = newConfig.orientation == Configuration.ORIENTATION_PORTRAIT        val rotation = act.windowManager.defaultDisplay.rotation        when (rotation) {          Surface.ROTATION_90 -> {            mBarProperty?.landscapeLeft = true            mBarProperty?.landscapeRight = false          }          Surface.ROTATION_270 -> {            mBarProperty?.landscapeLeft = false            mBarProperty?.landscapeRight = true          }          else -> {            mBarProperty?.landscapeLeft = false            mBarProperty?.landscapeRight = false          }        }        act.window.decorView.post(this)      }    }  }  override fun run() {    val act = mImmerseBar?.getActivity() ?: return    mBarProperty?.let {      val config = BarConfig(act)      it.statusBarHeight = config.mStatusBarHeight      it.hasNavigationBar = config.mHasNavigationBar      it.navigationBarHeight = config.mNavigationBarHeight      it.navigationBarWidth = config.mNavigationBarWidth      it.actionBarHeight = config.mActionBarHeight      val notchScreen = Notches.notchScreen(act)      it.notchScreen = notchScreen      if (notchScreen && 0 == mNotchHeight) {        mNotchHeight = Notches.notchHeight(act)        it.notchHeight = mNotchHeight      }      mOnBarListener?.onBarChange(it)    }  }}